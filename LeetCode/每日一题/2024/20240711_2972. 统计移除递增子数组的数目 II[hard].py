#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# @File    ：20240711_2972. 统计移除递增子数组的数目 II[hard].py
# @Author  ：Lin
# @Date    ：2024/7/11 10:14


"""给你一个下标从 0 开始的 正 整数数组 nums 。
如果 nums 的一个子数组满足：移除这个子数组后剩余元素 严格递增 ，那么我们称这个子数组为 移除递增 子数组。比方说，[5, 3, 4, 6, 7] 中的 [3, 4] 是一个移除递增子数组，因为移除该子数组后，[5, 3, 4, 6, 7] 变为 [5, 6, 7] ，是严格递增的。
请你返回 nums 中 移除递增 子数组的总数目。
注意 ，剩余元素为空的数组也视为是递增的。
子数组 指的是一个数组中一段连续的元素序列。
示例 1：
输入：nums = [1,2,3,4]
输出：10
解释：10 个移除递增子数组分别为：[1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4] 和 [1,2,3,4]。移除任意一个子数组后，剩余元素都是递增的。注意，空数组不是移除递增子数组。
示例 2：
输入：nums = [6,5,7,8]
输出：7
解释：7 个移除递增子数组分别为：[5], [6], [5,7], [6,5], [5,7,8], [6,5,7] 和 [6,5,7,8] 。
nums 中只有这 7 个移除递增子数组。
示例 3：
输入：nums = [8,7,6,6]
输出：3
解释：3 个移除递增子数组分别为：[8,7,6], [7,6,6] 和 [8,7,6,6] 。注意 [8,7] 不是移除递增子数组因为移除 [8,7] 后 nums 变为 [6,6] ，它不是严格递增的。
提示：
1 <= nums.length <= 105
1 <= nums[i] <= 109"""
from typing import List

"""方法一：双指针
思路

删除一个子数组后，整个数组还剩下前后两部分，需要满足这两个部分都是严格递增，
并且第一部分的最后一个元素小于第二个部分的第一个元素。

基于这个思路，可以采用双指针的思想，先用左指针从前开始扫，指针停在最长严格递增的位置 l。
如果 l 等于最后一个元素，表示删除任意一个子数组即可，
此时可直接计算答案。可以删除 n 个长度为 1的，n−1 个长度为 2 的... 1 个长度为 n 的子数组，
一共有  n×(n+1)//2  个子数组。
对于一般情况把右指针从后扫，当 nums[r]<=nums[l] 时，
此时把左指针 l 向前移动直到满足 nums[r]>nums[l] 即可。
此时可以删除子数组 [l,r−1]，[l−1,r−1] ... [0,r−1]，一共可贡献 l+2 个答案。
计算完 r 的答案后，继续向前移动右指针，当不满足 nums[r]<nums[r+1] 时，停止遍历。
"""
class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        l = 0
        res = 0
        while l < n - 1 and nums[l] < nums[l + 1]:
            l += 1
        if l == n - 1:
            return n * (n + 1) // 2
        res += l + 2

        for r in range(n - 1, 0, - 1):
            if r < n - 1 and nums[r] >= nums[r + 1]:
                break
            while l >= 0 and nums[l] >= nums[r]:
                l -= 1
            res += l + 2
        return res


s = Solution()
r = s.incremovableSubarrayCount(nums = [8,7,6,6])
print(r)

# r = s.incremovableSubarrayCount(nums = [1,2,3,4])
# print(r)
# r = s.incremovableSubarrayCount(nums = [8,1,2])
# print(r)
