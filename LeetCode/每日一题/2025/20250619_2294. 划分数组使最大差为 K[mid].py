#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2025/6/19 13:10
# @Author  : Lin
# @File    : 20250619_2294. 划分数组使最大差为 K[mid].py
"""给你一个整数数组 nums 和一个整数 k 。你可以将 nums 划分成一个或多个 子序列 ，使 nums 中的每个元素都 恰好 出现在一个子序列中。
在满足每个子序列中最大值和最小值之间的差值最多为 k 的前提下，返回需要划分的 最少 子序列数目。
子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。
示例 1：
输入：nums = [3,6,1,2,5], k = 2
输出：2
解释：
可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。
第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。
第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。
由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。
示例 2：
输入：nums = [1,2,3], k = 1
输出：2
解释：
可以将 nums 划分为两个子序列 [1,2] 和 [3] 。
第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。
第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。
由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。
示例 3：
输入：nums = [2,2,4,5], k = 0
输出：3
解释：
可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。
第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。
第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。
第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。
由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。
提示：
1 <= nums.length <= 105
0 <= nums[i] <= 105
0 <= k <= 105"""
from math import inf
from typing import List

"""只需要关心子序列的最大值和最小值，这与子序列的元素顺序无关。为方便计算，先把 nums 从小到大排序。

示例 1 的 nums=[3,6,1,2,5]，排序后为 [1,2,3,5,6]，分成 [1,2,3] 和 [5,6] 两组，分别对应原数组的子序列 [3,1,2] 和 [6,5]。

排序后，对于数组最小值 1 来说，所有与 1 相差 ≤k=2 的数都可以和 1 在同一组。由于我们已经把数组排序了，所以与 1 在同一组的数是连续的，即连续子数组 [1,2,3]。

现在问题变成：

把 nums 分割成若干段，每一段的首尾元素（最小值与最大值）之差 ≤k，最少分多少段？
从左到右遍历数组，记录当前这段的最小值 mn。如果 nums[i]−mn>k，说明 nums[i] 是下一段的最小值，那么把答案加一，同时更新 mn=nums[i]。

代码实现时，可以初始化 mn=−∞，而不是 nums[0]。如果把数据范围改成 nums 长度可以是 0，下面的代码仍然正确。
"""
class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = 0
        cur = -inf
        for x in nums:
            if cur + k < x:
                ans += 1
                cur = x
        return ans

s = Solution()
s.partitionArray(nums = [3,6,1,2,5], k = 2)
