#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @File  : 20231010_2731. 移动机器人.py
# @Author: Lin
# @Date  : 2023/10/10 17:18

"""有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。

给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。'L' 表示机器人往左或者数轴的负方向移动，'R' 表示机器人往右或者数轴的正方向移动。

当两个机器人相撞时，它们开始沿着原本相反的方向移动。

请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。

注意：

对于坐标在 i 和 j 的两个机器人，(i,j) 和 (j,i) 视为相同的坐标对。也就是说，机器人视为无差别的。
当机器人相撞时，它们 立即改变 它们的前进方向，这个过程不消耗任何时间。
当两个机器人在同一时刻占据相同的位置时，就会相撞。

例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。

例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。



示例 1：

输入：nums = [-2,0,2], s = "RLL", d = 3
输出：8
解释：
1 秒后，机器人的位置为 [-1,-1,1] 。现在下标为 0 的机器人开始往左移动，下标为 1 的机器人开始往右移动。
2 秒后，机器人的位置为 [-2,0,0] 。现在下标为 1 的机器人开始往左移动，下标为 2 的机器人开始往右移动。
3 秒后，机器人的位置为 [-3,-1,1] 。
下标为 0 和 1 的机器人之间距离为 abs(-3 - (-1)) = 2 。
下标为 0 和 2 的机器人之间的距离为 abs(-3 - 1) = 4 。
下标为 1 和 2 的机器人之间的距离为 abs(-1 - 1) = 2 。
所有机器人对之间的总距离为 2 + 4 + 2 = 8 。
示例 2：

输入：nums = [1,0], s = "RL", d = 2
输出：5
解释：
1 秒后，机器人的位置为 [2,-1] 。
2 秒后，机器人的位置为 [3,-2] 。
两个机器人的距离为 abs(-2 - 3) = 5 。


提示：

2 <= nums.length <= 105
-2 * 109 <= nums[i] <= 2 * 109
0 <= d <= 109
nums.length == s.length
s 只包含 'L' 和 'R' 。
nums[i] 互不相同。"""
from typing import List

"""方法一：脑筋急转弯 + 排序
思路与算法

当两个机器人相撞时，它们会沿着原本相反的方向移动。由于机器人之间并没有任何区别，相撞可以看做是穿透，原本左边的机器人相撞后交换为右边的机器人，原本右边的机器人相撞后交换为左边的机器人，这样一来，两个机器人仿佛没有相撞过。因此，我们可以无视相撞，独立计算每个机器人 ddd 秒后所处的位置。

记第 iii 个机器人 ddd 秒后的位置是 pos[i]\textit{pos}[i]pos[i]，对 pos\textit{pos}pos 数组进行排序，然后再计算两两之间的距离。

从小到大枚举 pos[i]\textit{pos}[i]pos[i]，此时左边有 iii 个数字，右边有 n−in - in−i 个数字（算上 pos[i]\textit{pos}[i]pos[i]），所以共有 i×(n−i)i \times (n - i)i×(n−i) 对数字在计算距离时会累加 pos[i]−pos[i−1]\textit{pos}[i] - \textit{pos}[i - 1]pos[i]−pos[i−1]。我们依次遍历完 [1,n−1][1, n - 1][1,n−1] 范围内所有的 pos[i]\textit{pos}[i]pos[i]，将 (pos[i]−pos[i−1])×i×(n−i)(\textit{pos}[i] - \textit{pos}[i - 1]) \times i \times (n - i)(pos[i]−pos[i−1])×i×(n−i) 累加到答案中即可。

需要注意的是，计算 pos[i]\textit{pos}[i]pos[i] 时不能进行取模，取模会破坏 pos\textit{pos}pos 间的大小关系，导致计算答案时 i×(n−i)i \times (n - i)i×(n−i) 无法乘上正确的距离。
"""
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        mod = 10 ** 9 + 7
        n = len(nums)
        nums = sorted([nums[i] + d if s[i] == 'R' else nums[i] - d for i in range(n)])

        return sum([(nums[i] - nums[i-1]) * i * (n - i) for i in range(1, n)]) % mod


s = Solution()
s.sumDistance(nums = [-2,0,2], s = "RLL", d = 3)





















